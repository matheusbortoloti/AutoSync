from __future__ import print_function
from collections import Iterable
import sys
import json
import copy
import re
import pprint

AUTO_SYNC_VALUE_ARG = "pvValue"
AUTO_SYNC_SHARED_VAR_ARG = "pvSharedVar"
AUTO_SYNC_SIZE_ARG = "xSizeData"
AUTO_SYNC_READ = "iAutoSyncRead"
AUTO_SYNC_WRITE = "iAutoSyncWrite"
AUTO_SYNC_READ_TO_UPDATE = "iAutoSyncReadToUpdate"
AUTO_SYNC_UPDATE = "iAutoSyncUpdate"
AUTO_SYNC_PROCEED_ON_EVENT = "iAutoSyncProceedOnEvent"
AUTO_SYNC_RET_VAL = "int8_t"
AUTO_SYNC_GENERATED = "/* Generated by AutoSync */\n"


MUTEX_LOCK = "pthread_mutex_lock"
MUTEX_UNLOCK = "pthread_mutex_unlock"

# This is not required if you've installed pycparser into your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import parse_file, c_generator, c_ast, c_parser
from IPython import embed

def del_duplicates(lis: list) -> list:
    '''
    Delete duplicates of a list
    '''
    return list(dict.fromkeys(lis))

# From StackExchange
def camel_to_snake(name):
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', name).upper()

def translate_to_c(filename):
    """ Simply use the c_generator module to emit a parsed AST.
    """
    ast = parse_file(filename, use_cpp=True,
                               cpp_path='gcc',
                               cpp_args=['-E', r'-Iutils/fake_libc_include'])

    print(ast)   

    generator = c_generator.CGenerator()
    print(generator.visit(ast))



def create_enum(name: str, enum_el: list) -> c_ast.Enum:
    el_list = []
    for idx, el in enumerate(enum_el):
        el_list.append(c_ast.Enumerator(camel_to_snake(el), None))

    return c_ast.Enum(name = name, values = c_ast.EnumeratorList(el_list))


# From StackExchange
def flatten(lis: list) -> list:
     for item in lis:
         if isinstance(item, Iterable) and not isinstance(item, str):
             for x in flatten(item):
                 yield x
         else:
             yield item


def create_shared_var_array(shared_vars: list, ast_arg: c_ast.FileAST) -> c_ast.FileAST:
    SHARED_VAR_ARRAY_NAME = "pvSharedVarArray"
    for node in ast_arg.ext:
        if type(node) == c_ast.Decl:
            if node.name == SHARED_VAR_ARRAY_NAME:
                ref_node = node.init.exprs
                break

    for var in shared_vars:
        new_node = copy.deepcopy(ref_node[0])
        new_node.expr.expr.name = var
        ref_node.append(new_node)

    del ref_node[0]

    return ast_arg


def create_shared_var_enum(shared_vars: list, ast_arg: c_ast.FileAST) -> c_ast.FileAST:
    SHARED_VAR_ENUM_NAME = "eSharedVars"

    for node in ast_arg.ext:
        if type(node) == c_ast.Decl and type(node.type) == c_ast.Enum:
            if node.type.name == SHARED_VAR_ENUM_NAME:
                node.type = create_enum(SHARED_VAR_ENUM_NAME, shared_vars)
                node.type.values.enumerators.append(c_ast.Enumerator(name  = 'NO_OF_SHARED_VAR',
                                                                     value = None))
                break

    return ast_arg


def decl_mutexes(mutexes: dict, events_mutexes: list) -> str:
    START_COMMENT = "/* (START) AutoSync: Automatically generated */\n"
    END_COMMENT = "/* (END) AutoSync: Automatically generated */\n"
    DECL_MUTEX = "pthread_mutex_t __DUMMY__;\n"   
    ATTR_MUTEX = "pthread_mutexattr_t xMutexAttr;\n"
    
    mutexes_to_declare = list(mutexes.values())
    mutexes_to_declare = del_duplicates(mutexes_to_declare)
    mutexes_to_declare += del_duplicates(events_mutexes)    

    decl = START_COMMENT 
    decl += ATTR_MUTEX
    for mutex in mutexes_to_declare:
        decl += DECL_MUTEX.replace("__DUMMY__", mutex)

    decl += END_COMMENT   
    return decl   


def decl_cond_var(events_cond_var: list) -> str:
    START_COMMENT = "/* (START) AutoSync: Automatically generated */\n"
    END_COMMENT = "/* (END) AutoSync: Automatically generated */\n"
    DECL_COND_VAR = "pthread_cond_t __DUMMY__;\n"       
    
    cond_var_to_declare = del_duplicates(events_cond_var)       

    decl = START_COMMENT    
    for cond_var in cond_var_to_declare:
        decl += DECL_COND_VAR.replace("__DUMMY__", cond_var)

    decl += END_COMMENT   
    return decl 


#def assign_event_counter_var(auto_sync_calls: dict) -> dict:
#    '''
#    Logic for assigning a counting variable to each event.
#    Returns a dictionary where every event is a key and has its associated counter variable.
#    EXAMPLE:
#        "TransposeDone": "uiCounter_TransposeDone"
#    '''    
#    COUNTER_VAR_NAME = "uiCounter__DUMMY__"
#
#    counter_vars = dict()
#    # Iterate through all calls to get the ones that contains xAutoSyncEvent as argument
#    # Example: "925": ["iAutoSyncProceedOnCondition", "xFFTDone", "P"]
#    for line, func_call in auto_sync_calls.items():
#        if func_call[0] == AUTO_SYNC_PROCEED_ON_EVENT:
#            event = func_call[1]
#            counter_vars[event] = COUNTER_VAR_NAME.replace("__DUMMY__", event)
#
#    return counter_vars


def decl_event_counter_var(events_counter_var: list) -> dict:
    '''
    Logic for declaring the counting variable associated to each event.
    Returns a string with the declarations.    
    '''    
    START_COMMENT = "/* (START) AutoSync: Automatically generated */\n"
    END_COMMENT = "/* (END) AutoSync: Automatically generated */\n"
    DECL_COUNTER_VAR = "uint32_t __DUMMY__;\n"       
    
    counter_var_to_declare = del_duplicates(events_counter_var)       

    decl = START_COMMENT    
    for counter_var in counter_var_to_declare:
        decl += DECL_COUNTER_VAR.replace("__DUMMY__", counter_var)

    decl += END_COMMENT   
    return decl 


def create_auto_sync_x(var: str, auto_sync_sig: str) -> c_ast.FileAST:
    if auto_sync_sig in [AUTO_SYNC_READ, AUTO_SYNC_WRITE]:
        TEMPLATE = "../00_AutoSync/01_Templates/mutex_read_write.c"
    elif auto_sync_sig in [AUTO_SYNC_READ_TO_UPDATE, AUTO_SYNC_UPDATE]:
        return "\n"
       #TEMPLATE = "../00_AutoSync/01_Templates/mutex_critical_section.c" removed 11.01.2022

    ast = parse_file(TEMPLATE, use_cpp=True,
                               cpp_path='gcc',
                               cpp_args=['-E', r'-Iutils/fake_libc_include'])

    for node in ast.ext:
        if type(node) == c_ast.FuncDef and node.decl.name == auto_sync_sig:
            node.decl.name += "_" + var
            node.decl.type.type.declname = node.decl.name
            
            for block in node.body.block_items:
                if isinstance(block, c_ast.FuncCall):
                    if block.name.name == MUTEX_LOCK or block.name.name == MUTEX_UNLOCK:
                        block.args.exprs[0].expr.subscript.name = camel_to_snake(var)
                        
            return node


def create_ast(ext: list) -> c_ast.FileAST:
    return c_ast.FileAST(ext=ext)

def get_info_from_parser(path_json: str):
    with open(path_json, "r") as file:
        json_file = json.load(file)

        threads_info = json_file[0]
        shared_var_types = json_file[1]
        auto_sync_calls = json_file[2]
        dependencies = json_file[3]
        intentions = json_file[4]


    return threads_info, shared_var_types, auto_sync_calls, dependencies, intentions


def create_auto_sync_impl(events_mutexes: list, events_cond_var: list, mutexes: dict, existing_shared_var: set, auto_sync_unique_calls: list):
    # Generate C code implementation
    with open("../05_Workspace/_AutoSync.c", "w") as f:
        f.write('#include <pthread.h>\n')
        f.write('#include <assert.h>\n')
        f.write('#include "_AutoSync.h"\n')

        f.write(create_auto_sync_create(events_mutexes, events_cond_var, mutexes))
        f.write(create_auto_sync_destroy(events_mutexes, events_cond_var, mutexes)) 

        #f.write(c_code_no_include)

def create_auto_sync_create(events_mutexes: list, events_cond_var: list, mutexes: dict) -> str:    
    SIGNATURE = "\nint8_t iAutoSyncCreate(void) \n{\n"
    INIT_ATTR_MUTEX = "  pthread_mutexattr_init(&xMutexAttr);\n"
    SET_ATTR_MUTEX = "  pthread_mutexattr_settype(&xMutexAttr, PTHREAD_MUTEX_RECURSIVE);\n\n"

    # Init mutexes
    func_body = SIGNATURE
    func_body += INIT_ATTR_MUTEX
    func_body += SET_ATTR_MUTEX
    unique_mutexes = del_duplicates(mutexes.values())
    unique_mutexes += del_duplicates(events_mutexes)
    for mutex in unique_mutexes:
        func_body += f"  assert(pthread_mutex_init(&{mutex}, &xMutexAttr) == 0);\n"

    # Init condition variables
    func_body += "\n"
    for cond_var in events_cond_var:
        func_body += f'  assert(pthread_cond_init(&{cond_var}, NULL) == 0);\n'
    
    func_body += "\n  return 0; \n}\n"

    return func_body

def create_auto_sync_destroy(events_mutexes: list, events_cond_var: list, mutexes: dict) -> str:    
    SIGNATURE = "\nint8_t iAutoSyncDestroy(void) \n{\n"

    # Destroy mutexes
    func_body = SIGNATURE
    unique_mutexes = del_duplicates(mutexes.values())
    unique_mutexes += del_duplicates(events_mutexes)
    for mutex in unique_mutexes:
        func_body += f"  assert(pthread_mutex_destroy(&{mutex}) == 0);\n"

    # Destroy condition variables
    func_body += "\n"
    for cond_var in events_cond_var:
        func_body += f'  assert(pthread_cond_destroy(&{cond_var}) == 0);\n'

    func_body += "\n  return 0; \n}\n"

    return func_body


def create_auto_sync_header(events_counter_var: list, events_mutexes: list, events_cond_var: list, auto_sync_unique_calls: list, mutexes: dict):
    with open("../00_AutoSync/AutoSync.h", "r") as header, open("../05_Workspace/_AutoSync.h", "w") as new_header:
        AUTO_SYNC_READ_SIGNATURE  = "int8_t iAutoSyncRead(void* pvValue, void* pvSharedVar, size_t xSizeData);\n"
        AUTO_SYNC_WRITE_SIGNATURE = "int8_t iAutoSyncWrite(void* pvSharedVar, void* pvValue, size_t xSizeData);\n"
        AUTO_SYNC_READ_TO_UPDATE_SIGNATURE  = "int8_t iAutoSyncReadToUpdate(void* pvValue, void* pvSharedVar, size_t xSizeData);\n"
        AUTO_SYNC_UPDATE_SIGNATURE = "int8_t iAutoSyncUpdate(void* pvSharedVar, void* pvValue, size_t xSizeData);\n"
        
        for line in header:

            if AUTO_SYNC_READ_SIGNATURE in line or AUTO_SYNC_WRITE_SIGNATURE in line or \
               AUTO_SYNC_READ_TO_UPDATE_SIGNATURE in line or AUTO_SYNC_UPDATE_SIGNATURE in line :
                pass
            elif "#endif" not in line:
                new_header.write(line)
            
            if "/* EXTERNAL VARIABLES */" in line:
                new_header.write(decl_mutexes(mutexes, events_mutexes))
                new_header.write("\n\n")
                new_header.write(decl_cond_var(events_cond_var))
                new_header.write("\n\n")
                new_header.write(decl_event_counter_var(events_counter_var))                

        for item in auto_sync_unique_calls:
            func_sig = item[0]
            shared_var = item[1]

            new_func_call = func_sig + "_" + shared_var
            if AUTO_SYNC_READ == func_sig:
                new_header.write(re.sub(func_sig, new_func_call, AUTO_SYNC_READ_SIGNATURE))
            if AUTO_SYNC_WRITE == func_sig:
                new_header.write(re.sub(func_sig, new_func_call, AUTO_SYNC_WRITE_SIGNATURE))
            #if AUTO_SYNC_READ_TO_UPDATE == func_sig:
            #    new_header.write(re.sub(func_sig, new_func_call, AUTO_SYNC_READ_TO_UPDATE_SIGNATURE))
            #if AUTO_SYNC_UPDATE == func_sig:
            #    new_header.write(re.sub(func_sig, new_func_call, AUTO_SYNC_UPDATE_SIGNATURE))
        new_header.write("#endif\n")


def replace_auto_sync_calls(path: str, auto_sync_calls: dict, mutexes: dict, intentions: dict, event_sync_mechanisms: dict):
    # Replace calls to the interface in the original file     
    with open(path, "r+") as source, open("../05_Workspace/temp.c", "w") as tmp:
        for line_no, line in enumerate(source):            
            line_no += 1     

            if str(line_no) in auto_sync_calls.keys():  
                func_sig = auto_sync_calls[str(line_no)][0]                 

                if func_sig == AUTO_SYNC_READ_TO_UPDATE:     
                    shared_var = auto_sync_calls[str(line_no)][1]              
                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We only assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_lock(&{mutexes[shared_var]});\n")

                    memcpy = line.replace("iAutoSyncReadToUpdate", "memcpy")
                    memcpy = re.sub(r"\,\s*\S*\)\;", ");", memcpy, 0, re.MULTILINE)
                    tmp.write(memcpy)
                elif func_sig == AUTO_SYNC_UPDATE:  
                    shared_var = auto_sync_calls[str(line_no)][1]                  
                    memcpy = line.replace("iAutoSyncUpdate", "memcpy")
                    memcpy = re.sub(r"\,\s*\S*\)\;", ");", memcpy, 0, re.MULTILINE)
                    tmp.write(memcpy)

                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We only assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_unlock(&{mutexes[shared_var]});\n") 
                elif func_sig == AUTO_SYNC_READ:
                    shared_var = auto_sync_calls[str(line_no)][1]
                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We on     ly assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_lock(&{mutexes[shared_var]});\n")

                    memcpy = line.replace("iAutoSyncRead", "memcpy")
                    memcpy = re.sub(r"\,\s*\S*\)\;", ");", memcpy, 0, re.MULTILINE)
                    tmp.write(memcpy)

                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We only assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_unlock(&{mutexes[shared_var]});\n")
                elif func_sig == AUTO_SYNC_WRITE:      
                    shared_var = auto_sync_calls[str(line_no)][1]

                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We only assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_lock(&{mutexes[shared_var]});\n")

                    memcpy = line.replace("iAutoSyncWrite", "memcpy")
                    memcpy = re.sub(r"\,\s*\S*\)\;", ");", memcpy, 0, re.MULTILINE)
                    tmp.write(memcpy)

                    if not ("bConstantInitByMain" in intentions[shared_var]):
                        # We only assign a lock if it is NOT a constant init by main
                        tmp.write(f"{AUTO_SYNC_GENERATED}pthread_mutex_unlock(&{mutexes[shared_var]});\n") 
                elif func_sig == AUTO_SYNC_PROCEED_ON_EVENT:
                    #embed()         
                    event = auto_sync_calls[str(line_no)][1]
                    event_mutex = event_sync_mechanisms[event][0]
                    event_cond_var = event_sync_mechanisms[event][1]
                    event_counter_var = event_sync_mechanisms[event][2]
                    event_no_of_threads = auto_sync_calls[str(line_no)][2] 
                    
                    barrier_body = f'pthread_mutex_lock(&{event_mutex});\n \
    {event_counter_var}++;\n \
    if ({event_counter_var} == {event_no_of_threads}) {{\n \
        {event_counter_var} = 0; \n \
        pthread_cond_broadcast(&{event_cond_var}); \n \
    }} \n \
    else {{ \n \
        pthread_cond_wait(&{event_cond_var}, &{event_mutex});\n \
    }} \n \
    pthread_mutex_unlock(&{event_mutex});' 

                    tmp.write(barrier_body)               

            elif re.match(r"(.*)(AutoSync\.h)", line):
                tmp.write("#include \"_AutoSync.h\"\n")
            elif re.match(r"(\W*iAutoSyncSharedVarAsArg)", line):
                tmp.write("")
            elif "xAutoSyncIntentions" in line:
                tmp.write("")
            
            else:
                tmp.write(line)


def assign_mutexes(shared_var_dependencies: dict) -> dict:
    '''
    Logic for assigning mutexes to the shared-variables based on the dependencies, type and quantity of accesses.
    Returns a dictionary where every shared-variable is a key and has its associated mutex.
    '''
    MUTEX_NAME = "xMutex__DUMMY__"
    mutexes = dict()
    for shared_var, dependencies in shared_var_dependencies.items():
        # If the shared-variable doesnt have an associated mutex, create one
        if shared_var not in mutexes.keys():
            mutexes[shared_var] = MUTEX_NAME.replace("_DUMMY__", shared_var.replace(".", "_").replace("->", "_"))
        
        # Assign the same lock for the dependencies
        for dependency in dependencies:
            mutexes[dependency] = mutexes[shared_var]
    
    pprint.pprint(mutexes)
    return mutexes


def assign_event_sync_mechanisms(auto_sync_calls: dict) -> dict:
    '''
    Logic for assigning mutexes and condition variables to the events.
    Returns a dictionary where every event is a key and has its associated mutex and conditon variable.
    EXAMPLE:
        "TransposeDone": ["xMutex_TransposeDone", "xCondVar_TransposeDone"]
    '''
    MUTEX_NAME = "xMutex__DUMMY__"
    COND_VAR_NAME = "xCondVar__DUMMY__"
    COUNTER_VAR_NAME = "uiCounter__DUMMY__"

    sync_mechanisms = dict()
    # Iterate through all calls to get the ones that contains xAutoSyncEvent as argument
    # Example: "925": ["iAutoSyncProceedOnCondition", "xFFTDone", "P"]
    for line, func_call in auto_sync_calls.items():
        if func_call[0] == AUTO_SYNC_PROCEED_ON_EVENT:
            event = func_call[1]
            sync_mechanisms[event] = (MUTEX_NAME.replace("_DUMMY__", event), \
                                      COND_VAR_NAME.replace("_DUMMY__", event), \
                                      COUNTER_VAR_NAME.replace("_DUMMY__", event))   
    
    pprint.pprint(sync_mechanisms)
    return sync_mechanisms

if __name__ == "__main__":
    
    # Open result file from parser and extract info
    threads_info, shared_var_types, auto_sync_calls, dependencies, intentions = get_info_from_parser("../05_Workspace/parser_out.json") 

    # Assign sync_mechanisms for the interface methods with events
    event_sync_mechanisms = assign_event_sync_mechanisms(auto_sync_calls)    
    events_mutexes = del_duplicates([sync_mech[0] for sync_mech in event_sync_mechanisms.values()])
    events_cond_var = del_duplicates([sync_mech[1] for sync_mech in event_sync_mechanisms.values()])
    events_counter_var = del_duplicates([sync_mech[2] for sync_mech in event_sync_mechanisms.values()])
   
    # Assign mutexes to the shared-variables based on the intentions
    mutexes = assign_mutexes(dependencies)
    
    existing_threads = list(threads_info.keys())
    existing_shared_var = list(mutexes.keys())
    
    # Create new source file replacing auto_sync calls in the original file
    replace_auto_sync_calls(sys.argv[1], auto_sync_calls, mutexes, intentions, event_sync_mechanisms)
                
    # Generate header file
    # Eliminate duplicated calls because we only need to declare it once
    auto_sync_unique_calls = list(set(map(lambda i: tuple(sorted(i)), [item[1] for item in auto_sync_calls.items()])))
    create_auto_sync_header(events_counter_var, events_mutexes, events_cond_var, auto_sync_unique_calls, mutexes)
    
    # Create _AutoSync.c
    create_auto_sync_impl(events_mutexes, events_cond_var, mutexes, existing_shared_var, auto_sync_unique_calls)

    # Print success message
    print(f'Code generation was successful! Please see the file \"../05_Workspace/temp.c\"')
   

  

    
